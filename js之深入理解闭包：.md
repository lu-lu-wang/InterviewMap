### js之深入理解闭包：
MDN对于闭包的定义为： 闭包是指那些能够访问自由变量的函数。
那什么是自由变量呢？
自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。
由此我们可以看出闭包有两部分组成：
闭包 = 函数 + 函数能够访问的自由变量 举例：
	
	var a = 1
	function foo(){
		console.log(a)
	}
	foo()
	
	其中foo函数可以访问变量a，但是a既不是foo函数的局部变量，也不是foo函数的参数，所以a就是自由变量。
	那么，函数foo+foo函数访问的自由变量a就构成了一个闭包

ECMAScript中，闭包指的是：

	1. 从理论角度：所有的函数，因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。
	2. 从实践角度： 以下函数才算是闭包：
		1.即使创建他的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
		2.在代码中引用了自由变量

### 调用栈
调用栈是解释器（就像浏览器中的js解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到那个函数正在执行，执行的函数中又调用了那个函数。

	· 每调用一个函数，解释器就会把该函数添加进调用栈开始执行
	· 正在调用栈中执行的函数还调用了其它函数，那么弦函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。
	· 当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余代码。
	· 当分配的调用栈空间被占满时，会引发‘堆栈溢出’。
	函数在执行过程中其实就是：一开始，我们得到一个空的调用栈，随后，每当有函数被调用都会自动添加进调用栈，执行完函数体的代码后，调用栈又会自动地移除这个函数。最后，我们又得到了一个空的调用栈。

### 深入理解js是如何工作的？
js引擎由两部分组成：
	1. 内存栈： 这是内存分配发生的地方
	2. 调用栈： 这是代码执行时的地方

	调用栈：js是一门单线程语言，这意味着它只有一个调用栈，因此，它同一时间只能做一件事。
	调用栈是一种数据结构，它记录了我们在程序中的位置，如果我们运行到一个函数，它会将其放置到栈顶。当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事。

### 并发与事件循环
调用栈中的函数调用需要大量的时间来处理，那么这会发生什么情况呢？例如浏览器中使用js进行一些复杂的图片转码。

	事实上，问题是当调用栈有函数要执行，浏览器就不能做任何事，他会被堵住。这意味着浏览器不能渲染，不能运行其他的代码，它被卡住了，如果你想在应用里让ui流畅的话，就会产生问题。而这不是唯一的问题，一旦你的浏览器开始处理调用栈中的众多人物，它可能会停止响应相当长一段时间，大多数浏览器会报一个错，询问是否终止web页面。

### js的执行上下文？
执行上下文是评估和执行js代码的环境的抽象概念，每当js代码在运行的时候，它都是在执行上下文中运行。
执行上下文的类型：js中有三种执行上下文类型
	
		· 全局执行上下文 -- 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的window对象（浏览器的情况下），并且设置this的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
		· 函数执行上下文 -- 每当一个函数被调用时，都会为该函数创建一个新的上下文。每个函数都有自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤。
		· Eval函数执行上下文 -- 执行在eval函数内部的代码也会有它属于自己的执行上下文。（不常用）

### 执行栈
	执行栈就是调用栈，是一种拥有‘先进后出’数据结构的栈，被用来存储代码运行时创建的所有执行上下文。当js引擎第一次遇到你的脚本时，它会创建一个全局的指向上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈顶。
	引擎会执行那些执行上下文栈顶的函数，当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。

在js代码执行前，执行上下文将经历创建阶段，在创建阶段会发生三件事：
	1. this值得决定，即我们所熟知的this绑定。
	2. 创建词法环境组件。
	3. 创建变量环境组件。

this绑定： 
在全局执行上下文中，this的值指向全局对象。
在函数执行上下文中，this的值取决于该函数如何被调用的。如果它被一个引用对象调用，那么this会被设置成那个对象，否则this的值被设置为全局对象或者undefined（在严格模式下）

### 词法环境
词法环境是一种规范类型，基于ECMAScript代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境有环境记录器和一个可能的引用外部词法环境的空值组成。
简单来说词法环境是一种持有标识符--变量映射的结构。（这里的标识符指的是变量/函数的名字，而变量是对实际对象【包含函数类型对象】或原始数据的引用）。
词法环境内部有两个组件：1.环境记录器 2.外部环境的引用 1. 环境记录器是存储变量和函数声明的实际位置
2. 外部环境的引用意味着它可以访问其父级词法环境（作用域）


	词法环境有两种类型：
	  · 全局环境（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是null。它拥有内建的object、array等，在环境记录器内的原型函数（管理全局对象，比如window对象）还有任何用户定义的全局变量，并且this的值指向全局对象。
	  · 在函数环境中，函数内部用户定义的变量存储在环境记录器中，并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。

### 彻底弄懂js执行机制
· js是按照语句出现的顺序执行的（即一句一句执行）

		1. 关于js：js是一门单线程语言，在最新的html5中提出了web-worker,但js是单线程这一核心仍未改变。所以一切js版的‘多线程’都是用单线程模拟出来的，一切js多线程都是纸老虎😂
		2. js事件循环： 既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个个办理业务，同理js任务也要一个个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。所以任务就可分为两类：
		  · 同步任务
		  · 异步任务
		当我们打开网页时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。那些占用资源大且耗时持久的任务，就是异步任务。

	· 同步和异步任务分别进入不同的执行‘场所’，同步的进入主线程，异步的进入event table并注册函数。
	· 当指定的事件完成时，event table会将这个函数移入event queue(事件队列)
	· 当主线程内的任务执行完毕为空时，会去event queue读取对应的函数，进入主线程执行
	· 上述过程会不断的重复，形成event loop（事件循环）
	
那么我们如何知道主线程执行栈为空呢？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去event queue哪里检查是否有等待被调用的函数。

	let data = []
	$.ajax({
		url: www.js.com,
		data: data,
		success: () => {
			console.log(‘成功！’)
		}	
	})
	console.log(‘结束！’)
上面是一段简易的ajax请求代码：

	· ajax进入event table,注册回调函数success
	· 执行console.log(‘代码执行结束’)
	· ajax事件完成，回调函数success进入event queue
	· 主线程从event queue读取回调函数success并执行

setTimeout(fn,0)这样的代码，0秒后执行又是啥意思呢？是可以立即执行么？


	答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用等多少秒，只要主线程执行栈的同步任务全部执行完，栈为空就马上执行。（需要注意的是，即便主线程为空，0ms也是达不到的，根据html标准，最低也是4ms）

### setInterval
	 	setInterval是循环执行，对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入event queue，如果前面任务耗时久，同样需要等待。需要注意的是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms，会有fn进入event queue，一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出有间隔了。

### Promise与process.nextTick(callback)
process.nextTick(callback)类似于node.js版的‘setTimeout’，在事件循环的下一次循环中调用callback回调函数。


除了广义的同步任务和异步任务，我们队任务有更精细的定义：

	· macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
	· micro-task(微任务)：Promise，process.nextTick
	
不同类型的任务会进入对应的event queue,比如setTimeout和setInterval会进入相同的event queue。

事件循环的顺序，决定js代码的执行顺序，进入整体代码（宏任务）后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。

### 原始数据
基本类型（基本数值、基本数据类型）是一种既非对象也无方法的数据。在js中，共有6中基本类型：string,number,boolean,null,undefined,symbol.
多数情况下，基本类型直接代表了最底层的语言实现
所有的基本类型的值都是不可改变的。但需注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原始值不能像数组、对象及函数那样被改变。

	例子： // 使用字符串方法不会改变一个字符串
		var bar = ‘baz’
		console.log(bar)     // baz
		bar.toUpperCase()  
		console.log(bar)    // baz 未发生改变
		
		bar = bar.toUpperCase()  // BAZ
		// 说明赋值行为可以为基本类型一个新值，而不是改变它
		
		基本类型可以被替换，但不能被改变

		let foo = 5
		function foo (foo) {foo+=2}
		add(foo)
		console.log(foo)  // 5
		
		· 在函数被调用时，js会检查标识符foo的值，从而准确无误的找到第一行实例化变量的声明语句
		· 找到后，js将其作为参数传递给函数的形参
		· 在执行函数体内语句之前，js会将传递进来的参数（基本类型的值）复制一份，创建一个本地副本。这个副本只存在于该函数作用域中，我们能够通过指定在函数中的标识符访问到它
		· 接下来，函数体中的语句开始执行：
			· 第一个函数中创建了本地参数foo，并将其加2，这个值不是外部foo的值，在这种情况下，外部的foo不能以任何形式被访问到，这是因为js的词法作用域所导致的变量覆盖，本地的变量foo覆盖了外部的变量foo（闭包）
		. 综上，函数中的任何操作都不会影响到最初的foo，我们能操作的只有它的副本。

### js值引用和复制
		js值类型：基础类型、复杂类型、特殊类型
		ES5中有6中数据类型：null、undefined、number、boolean、string、object
		复杂类型是指object即广义的对象类型，可由多个简单类型的值合成，可以看做是一个存放各种值得容器，例如arr、object、regx等
		基础类型是指：number、string、boolean
		特殊类型是指：null、undefined
		基础类型和复杂类型的区别： 基础类型将内容直接存储在栈中（大小固定位置连续的存储空间），记录的是该数据类型的值，即直接访问，基础类型赋值是复制（copy）；复杂类型将内容存储在堆中，堆所对应的栈中记录的是指针（堆的地址），外部访问时先引出地址，再通过地址去找到值所存放的位置。

	值类型和引用类型的区别：
	1. 值类型 ： 
		1、 占用空间固定，保存在栈中。（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存中，随着方法的执行结束，这个方法的内存栈也将被销毁。）
		2、保存与复制的是值本身
		3、使用typeof检测数据的类型
		4、基本类型数据是值类型
	2. 引用类型：
		1、占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（如方法的参数传递），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用时，系统的垃圾回收机制才会在合适的时候回收）
		2、保存与复制的是指向对象的一个指针
		3、使用instanceof检测数据类型
		4、使用new()方法构造出的对象是引用型

复制值类型，会产生两个新栈，完全独立，故操作任何一个都不会相互影响。

复制引用类型，会产生两个变量。但是指向同一个指针，而这个指针指向存储堆中的同一个对象。实际上两个变量引用同一个对象，任意一个变量发生变化都会相互影响。

传递参数：在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量。在向参数擦魂帝引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

### 深入理解js之typeof和instanceof
typeof()方法返回的是一个字符串，来自于数据的类型：

	Undefined -> ‘undefined’
	Null -> ‘null’
	布尔值 -> ‘boolean’
	数值 -> ‘number’
	字符串 -> ’string’
	Symbol(ES6新增) -> ‘symbol’
	宿主对象(JS环境提供，比如浏览器) -> Implementation-dependent
	函数对象 -> ‘function’
	任何其他对象 -> ‘object’

但是我们发现typeof来判断数据类型其实并不准确。比如数据、正则、日期、对象的typeof返回值都是object，会造成误差。
### 所以在typeof判断类型的基础上，我们需要利用Object.prototype.toString方法来进一步判断数据类型

	数据					toString			typeof
	
	‘foo’					String				string
	new String(‘foo’)	String				object
	new Number(1.2)		Number				object
	true					Boolean			boolean
	new Boolean(true)	Boolean			object
	new Date()			Date				object
	new Array(1,2)		Array				object
	new Error()			Error				object
	/abc/g					RegExp				object
	new.RegExp(’now’)	RegExp				object
	
	可以看到通过toString方法乐意区分出Array、Error、RegExp、Date等类型

### instanceof
instanceof运算符可以用来判断某个构造函数prototype属性是否存在于另一个要检测对象的原型链上。

instanceof左操作数是一个类，右操作数是标识对象的类。如果左侧的对象是右侧类的实例，则返回true，而js中对象的类是通过初始化它们的构造函数来定义的，即instanceof右操作数应该是一个函数，所有的对象都是object的实例，如果左操作数不是对象，则返回false，如果右操作数不是函数，则抛出typeError。
instanceof运算符是用来测试一个对象是否在其原型链原型构造函数的属性。其语法是object instanceof constructor

	
	例子：
	console.log(a instanceof Number) // false
	console.log(true instanceof Boolean) // false
	console.log(’str’ instanceof String) // false
	console.log([] instanceof Array) // true
	console.log(function(){} instanceof Function)// true	
	console.log({} instanceof Object) // true
	
	// 以上结果显示，直接的字面量值判断数据类型，只有引用数据类型（Array,Object,Function）被精准的判断，	
判断具体对象类型可用Object.prototype.toString.call()方法，使用Object对象的原型方法toString，使用call进行狸猫换太子，借用Object的toString方法。

	例子：
	var a = Object.prototype.toString
	console.log(a.call(’99’)) // ‘[Object String]’
	console.log(a.call([]))  // ‘[Object Array]’
	console.log(a.call(true)) // ‘[Object Boolean]’
	console.log(a.call(function(){})) //‘[object Function]’
	console.log(a.call(undefined)) // ‘[Object Undefined]’
	console.log(a.call(null)) // ‘[Object Null]’

结果精准的显示我们需要的数据类型，就算我们改变对象的原型，它依然会显示正确的数据类型

总结：简单来说，我们使用typeof来判断基本数据类型是ok的，不过需要注意当用typeof来判断null类型的时候，如果想要判断一个对象具体类型可以用instanceof，但是instanceof也不准确，比如一个数组，他可以被instanceof判断为Object，所以想比较准确判断对象实例的类型时，可以采取Object.prototype.toString.call方法。

### 词法作用域
一般来说，在编程语言里我们常见的变量作用域就是词法作用域与动态作用域，绝大部分的编程语言都是使用的词法作用域。词法作用域注重的是所谓的write-time,即编程时的上下文，而动态作用域以及常见的this用法，都是run-time，即运行时上下文。词法作用域关注的是函数在何处被定义，而动态作用域关注的是函数在何处被调用。js是典型的词法作用域语言，即一个符号参照到语境中符号名字出现的地方，局部变量缺省有着词法作用域。

### 闭包
闭包本身是含有自由变量的代码块，在js中我们常用的闭包则是本身的词法作用域与变量保留相结合的表现，首先回顾下一个基本的词法作用域用法。	

		function init() {
			var name= “mozilla”
			function displayName() {
				alert(name);
			}
			displayName();
		}
		init();
	
	
		
		
		
		
		




	
 

