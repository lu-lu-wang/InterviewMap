## JS高程中的垃圾回收机制与常见内存泄漏的解决方法

#### 内存的生命周期
1.分配你所需的内存

由于字符串、对象等没有固定的大小，js程序在每次创建字符串、对象的时候，程序都会分配内存来存储那个实体

2.使用分配到的内存做点什么

3.不需要时将其释放回归

在不需要字符串、对象的时候，需要释放其所长用的内存，否则将会消耗完系统内所有可用的内存，造成系统崩溃，这就是垃圾回收机制存在的意义。

所谓的内存泄漏指的是：由于疏忽或错误造成未能释放那些已经不再使用的内存，造成内存的浪费

#### 垃圾回收机制：
在编写js的过程中，内存的分配以及内存的回收完全实现了自动管理

垃圾回收机制的原理：

垃圾收集器会按照固定的时间间隔，周期性的找出不再继续使用的变量，然后释放其占用的内存。

哪些是我们不再继续使用的变量？

不再使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用（闭包），那么该变量就会被标记回收。
全局变量的生命周期直至浏览器卸载页面才会结束，所以说全局变量不会被当成垃圾回收，所以声明全局变量要慎重。

### 标记清除：当前采用的垃圾收集策略
工作原理：

当变量进入环境时（例如在函数中声明一个变量），将这个变量标记为‘进入环境’，当变量离开环境时，将其标记为‘离开环境’.标记‘离开环境’的就回收内存。

工作流程：

	1.垃圾回收器会在运行的时候会给存储在内存中的所有变量都加上标记。
	2.去掉环境中的变量以及被环境中的变量引用的变量的标记
	3.那些还存在标记的变量被视为准备删除的变量。
	4.最后垃圾收集器会执行最后一步内存清除工作，销毁那些带标记的值并回收它们所占用的内存。
哪些情况会引起内存泄漏？

虽然有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏。

	1.意外的全局变量：全局变量不会被当做垃圾回收。所以我们可以手动释放全局变量的内存（window.bar=undefined  delete window.bar2）
	2.被遗忘的定时器和回调函数：但不需要setTimeout或者setInterval时，定时器没有没clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。所以我们要在定时器完成工作时，手动清除定时器。
	3.闭包：闭包可以维持函数内部的局部变量，使其得不到释放，造成内存泄漏，所以我们可以手动解除引用
	function bindEvent(){
		var obj = document.creactElement(‘xxx’)
		var unused = function () {
		console.log(obj,’闭包内引用obj obj不会被释放’)
		
		}
		// 手动解除引用
		obj = null
	}
	4.console保存大量数据在内存中
	过多的console，比如定时器的console会导致浏览器卡死

### 如何避免内存泄漏？
1.减少不必要的全局变量，使用严格模式避免意外创建全局变量。

2.在使用完数据后，及时解除引用（闭包中的变量，dom引用，定时器清除）

3.组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题

基本类型的值存在内存中，被保存在栈内存中，引用类型的值是对象，保存在堆内存中。所以对象、数组之类的，才会发生内存泄漏。






