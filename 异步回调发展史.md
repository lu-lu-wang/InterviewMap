异步的发展过程：

发展过程：
#### callback->promise->generator+co->async+await(语法糖)
在es6诞生以前，异步编程的方法：

·回调函数

·事件监听

·发布/订阅

·Promise对象

Generator函数将js异步编程带入了一个全新的阶段


注：异步是不支持try/catch的，try/catch只能在同步中使用

|
|
|
|
| 

|	|
|	|
|

js是一门单线程语言，单线程就意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不等着。

如果排队是因为计算量大，cpu忙不过来就算了，关键是大多数之后CPU都是闲着，因为io设备很慢，（比如ajax操作要从网络读取数据），不得不等结果后再向下执行。


js设计者就意识到，这时主线程完全可以不管io设备，挂起处于等待中的任务，先运行排在后面的任务，等到IO设备返回了结果，再回头把挂起的任务继续执行下去。

于是，所有任务可以分为两种：一种是同步任务，另一种是异步任务。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入到主线程执行

异步执行的运行机制：
1.所有同步任务都在主线程执行，形成一个执行栈
2.主线程之外，存在任务队列。只有异步任务有了运行结果，就会在任务队列中放置一个事件
3.一旦执行栈中所有的同步任务执行完毕，系统会读取任务队列，看看里面有哪些事件，那些对应异步任务，于是结束等待状态，进入执行栈，开始执行
4.主线程不断重复步骤三

任务队列是一个事件的队列（也可理解为消息队列），IO设备完成一项任务，就会在任务队列中添加一个事件，表示相关的异步任务可以进入执行栈了，主线程读取任务队列，就是读取有什么事件。

任务队列中的事件除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击，页面滚动等）。只要指定过回调函数，这些事件就会进入到任务队列，等待主线程读取

所谓回调函数（callback）就是那些会被主线程挂起来的代码，异步任务必须要指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

任务队列是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程是自动，只要执行栈一清空，任务队列上第一位的事件就自动进入到主线程，其次，由于定时器的功能，主线程要先检测下执行事件，某些事件只有到了规定的时间，才能返回主线程。

EventLoop
主线程从任务队列中读取事件，这个过程是循环不断地，整个运行机制成为事件循环

在单线程的js中，异步代码会被放入一个事件队列，等到其他所有代码执行后再执行，而不会阻塞线程。

异步函数：

1.setTimeout和setInterval被压入了称之为EventLoop的队列

EventLoop是一个回调函数队列，当异步函数执行时，回调函数会被压入到这个队列，js引擎直到异步函数执行完成后，才会开始处理事件循环，这就意味着js代码不是多线程的，即使表现行为相似。事件循环是一个先进先出的队列，回调也是按照被加入队列的顺序执行的

2.ajax也是异步的

3.node.js中的许多函数也是异步的

callback地狱回调：

1.不要多层嵌套函数。给函数命名，并且放置在程序顶层

2.好好利用js的函数声明提升这一特性，将函数放置在文件末尾

3.处理好函数回调过程中每一个可能报错的信息

4.编写可复用的函数并将其模块化，提高可读性，将代码拆分成多个组件，有利于处理错误信息，编写测试程序

# co: 
#### co是express和koa的作者tj大神基于es6 generator和promise实现的一个解决js异步回调嵌套地狱的库，可谓是短小精悍。co允许我们像写同步代码一样去写异步代码，并且可以用try/catch捕获异常，调用co始终返回一个peomise所以可用then/catch

### co源码

1.调用co始终返回一个promise，这也是co后面可以跟try/catch的原因

2.co的核心就是通过next方法不断调用generator的next方法，直到generator执行完毕

3.yield后面跟funcion、promise、generator、array、object，然后调用toPromise方法将以上几种数据格式都转化为promise

4.可以通过co.wrap把一个generator函数转化为promise，原理是co.wrap内部调用了co函数，因为co始终返回一个promise，所以co.wrap可以将generator函数转化为promise，另外如果需要调用两个除了参数不同其余都相同的co，此时可以用co.wrap()返回普通函数代理实参调用

## 并发执行await命令
当一个async函数中有多个await时，这些await是继发执行的，只有当前一个await后面的方法执行完毕后，才会执行下一个。

如果我们前后的方法是有依赖关系的，继发执行是没有问题的，但是如果没有任何关系的话，是跟浪费的，所以需要这些await命令同时执行，也就是并发执行。

方法一：

	let [res1,res2] = await Promise.all([fun1(),func2()])

方法二：

	let func1Promise = fun1()
	let func2Promise = fun2()
	let res1 = await func1Promise
	let res2 = await func2Promise





## JS异步、栈、事件循环、任务队列

我们经常会听到引擎和runtime，它们的区别是什么呢？

· 引擎：解释并编译代码，让它能交给机器运行的代码

· runtime：就是运行环境，它提供一些对外接口供js调用，以跟外界打交道，比如，浏览器、node.js环境，不同的runtime，会提供不同的接口，比如，在Node.js环境中，我们可以通过require来引入模块，而在浏览器中，我们有window、dom

js引擎是单线程，负责维护任务队列，并通过Even Loop的机制，按顺序把任务放入执行栈中，异步处理模块，就是runtime提供的，拥有和js引擎互不干扰的线程

## 栈

函数的入栈、出栈操作主要是先执行主线程，发现是异步函数，丢给异步处理模块，并出栈，主线程任务执行完就依次出栈，直至最后清空栈，这时候就可以取任务队列的任务来执行了。

## 任务队列
js中，有两类任务队列：宏任务队列（macro task）和微任务队列（micro task）,宏任务可以有多个，微任务队列只有一个。

宏任务： script（全局任务）、setTimeout、setInterval、setImmediate、I/O,UI rendering

微任务：process.nextTick,Promise,Object.observer,MutaitionObserver

## 浏览器的Event Loop

浏览器的Event Loop遵循的是html5标准，而NodeJs的Event Loop遵循的是libuv

上面说到当stack空的时候，就会从任务队列中，取任务来执行，浏览器这边，共3步：

1.取一个宏任务来执行，执行完毕后，下一步

2.取一个微任务来执行，执行完毕后，再取一个微任务来执行。直到微任务队列为空，执行下一步

3.更新UI渲染

Event Loop会无限循环执行上面3步,这就是Event Loop的主要控制逻辑，其中，第3步（更新渲染ui）会根据浏览器的逻辑，决定要不要马上执行更新，毕竟更新UI成本大，所以一般都会比较长的时间间隔，执行一次更新。

从执行步骤来看，我们发现微任务，收到了特殊待遇，我们代码开始执行都是从script（全局任务）开始，所以，一旦我们的全局任务（属于宏任务）执行完，就马上执行完整个微任务队列

NodeJs的Event Loop

NodeJs的运行时这样的：

·初始化Event Loop

·执行您的主代码。遇到异步处理，就会分配给对应的队列，直到主代码执行完毕

·执行主代码中出现的所有的微任务，限制性能改完所有的nextTick(),然后再执行其他所有的微任务

·开始Event Loop

### 事件循环的进程模型
	· 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务的执行步骤。
	· 将事件循环中的任务设置为已选择任务。
	· 执行任务
	· 将事件循环中当前运行任务设置为null。
	· 将已经运行完成的任务从任务队列中删除
	· microtasks步骤：进入microtask检查点
	· 更新界面渲染
	· 返回第一步

#### 执行进入microtask检查点时，用户代理会执行以下步骤：
	· 设置microtask检查点标志为true
	· 当事件循环microtask执行不为空时：选择一个最先进入的microtask队列的microtask，将事件循环的microtask设置为已选择的microtask，运行microtask，将已经执行完成的microtask为null，移出microtask中的microtask。
	· 清理indexDB事务
	· 设置进入microtask检查点标志位false
	执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就去检查微任务，













